(function () {
  window.DENO_DOC_SEARCH_INDEX = {"kind":"search","nodes":[{"id":"namespace_Any","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"Any","file":".","doc":"Real any type.","url":"././~/Any.html","deprecated":false},{"id":"namespace_Ctr","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"Ctr","file":".","doc":"Constructor type for classes.","url":"././~/Ctr.html","deprecated":false},{"id":"namespace_DependsOn","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"DependsOn","file":".","doc":"Mark an injectable as depending on other tokens. This function can be used to specify dependencies that the injectable requires to function properly. It can be used in the context of an injectable descriptor to define its dependencies.","url":"././~/DependsOn.html","deprecated":false},{"id":"namespace_DescriptorFn","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"DescriptorFn","file":".","doc":"Descriptor function type for modifying descriptors. It takes a partial descriptor and returns a modified partial descriptor. This is used in decorators to build up metadata for injectables and modules.","url":"././~/DescriptorFn.html","deprecated":false},{"id":"namespace_Factory","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"Factory","file":".","doc":"Factory type for creating instances of a dependency from a token.","url":"././~/Factory.html","deprecated":false},{"id":"namespace_Imports","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"Imports","file":".","doc":"Mark a module as importing other modules. This function can be used to specify other modules that the current module depends on. It can be used in the context of a module descriptor to define its imports.","url":"././~/Imports.html","deprecated":false},{"id":"namespace_Injectable","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"Injectable","file":".","doc":"Mark a class as injectable.This decorator allows the class to be used as a dependency in the dependency injection system. It can be used to define dependencies that the class requires to function properly. The dependencies can be specified using the dependsOn function.","url":"././~/Injectable.html","deprecated":false},{"id":"namespace_InjectableDescriptor","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"InjectableDescriptor","file":".","doc":"Injectable descriptor for defining dependencies of an injectable class. It includes a list of tokens that the injectable depends on.","url":"././~/InjectableDescriptor.html","deprecated":false},{"id":"namespace_InjectableDescriptor","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"InjectableDescriptor.dependencies","file":".","doc":"","url":"././~/InjectableDescriptor.dependencies.html","deprecated":false},{"id":"namespace_InjectableMetadata","kind":[{"char":"v","kind":"Variable","title":"Variable"}],"name":"InjectableMetadata","file":".","doc":"","url":"././~/InjectableMetadata.html","deprecated":false},{"id":"namespace_Injector","kind":[{"char":"c","kind":"Class","title":"Class"}],"name":"Injector","file":".","doc":"Dependency Injector This class is responsible for resolving dependencies and managing the lifecycle of instances. It implements the Resolver interface and provides methods to resolve tokens, create instances, and manage providers.","url":"././~/Injector.html","deprecated":false},{"id":"namespace_Injector","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Injector.prototype.resolve","file":".","doc":"Resolve a token to its corresponding instance.","url":"././~/Injector.prototype.resolve.html","deprecated":false},{"id":"namespace_Injector","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Injector.prototype.search","file":".","doc":"Search for a provider by its token in the current module and its imports. If not found locally, it will recursively search in imported modules.","url":"././~/Injector.prototype.search.html","deprecated":false},{"id":"namespace_Injector","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Injector.prototype.provider","file":".","doc":"Get a provider by its token.","url":"././~/Injector.prototype.provider.html","deprecated":false},{"id":"namespace_Injector","kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Injector.prototype.create","file":".","doc":"Create an instance of a class with its dependencies resolved.","url":"././~/Injector.prototype.create.html","deprecated":false},{"id":"namespace_Injector","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"Injector.prototype.name","file":".","doc":"","url":"././~/Injector.prototype.name.html","deprecated":false},{"id":"namespace_Injector","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"Injector.prototype.desc","file":".","doc":"","url":"././~/Injector.prototype.desc.html","deprecated":false},{"id":"namespace_InjectorMetadata","kind":[{"char":"v","kind":"Variable","title":"Variable"}],"name":"InjectorMetadata","file":".","doc":"","url":"././~/InjectorMetadata.html","deprecated":false},{"id":"namespace_Instance","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"Instance","file":".","doc":"Instance type for objects. This is a utility type that represents an instance of a given object type.","url":"././~/Instance.html","deprecated":false},{"id":"namespace_MethodContext","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"MethodContext","file":".","doc":"Class decorator context (decorators stage 3, TC39) This is used in class decorators to provide metadata and utilities.","url":"././~/MethodContext.html","deprecated":false},{"id":"namespace_MethodContext","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"MethodContext.kind","file":".","doc":"","url":"././~/MethodContext.kind.html","deprecated":false},{"id":"namespace_MethodContext","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"MethodContext.name","file":".","doc":"","url":"././~/MethodContext.name.html","deprecated":false},{"id":"namespace_MethodContext","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"MethodContext.static","file":".","doc":"","url":"././~/MethodContext.static.html","deprecated":false},{"id":"namespace_MethodContext","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"MethodContext.private","file":".","doc":"","url":"././~/MethodContext.private.html","deprecated":false},{"id":"namespace_MethodContext","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"MethodContext.metadata","file":".","doc":"","url":"././~/MethodContext.metadata.html","deprecated":false},{"id":"namespace_MethodContext","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"MethodContext.addInitializer","file":".","doc":"","url":"././~/MethodContext.addInitializer.html","deprecated":false},{"id":"namespace_MethodContext","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"MethodContext.access","file":".","doc":"","url":"././~/MethodContext.access.html","deprecated":false},{"id":"namespace_MethodContext","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"MethodContext.access.get","file":".","doc":"","url":"././~/MethodContext.access.get.html","deprecated":false},{"id":"namespace_Module","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"Module","file":".","doc":"Mark a class as a module.This decorator allows the class to be used as a module in the dependency injection system. It can be used to define providers and imports that the module requires. The providers can be specified using the provide function, and imports can be specified using the imports function.","url":"././~/Module.html","deprecated":false},{"id":"namespace_ModuleDescriptor","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"ModuleDescriptor","file":".","doc":"Module descriptor for defining imports and providers of a module. It extends the InjectableDescriptor to include dependencies. It includes a list of imported modules and a list of providers defined in the module.","url":"././~/ModuleDescriptor.html","deprecated":false},{"id":"namespace_ModuleMetadata","kind":[{"char":"v","kind":"Variable","title":"Variable"}],"name":"ModuleMetadata","file":".","doc":"","url":"././~/ModuleMetadata.html","deprecated":false},{"id":"namespace_Provide","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"Provide","file":".","doc":"Create a provider for a token. This function can be used to provide a value using a factory function or a class as a dependency. Should be run in creating module context only (Module Decorator).","url":"././~/Provide.html","deprecated":false},{"id":"namespace_Provider","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"Provider","file":".","doc":"Provider type for defining how to provide a dependency. It includes a token to identify the dependency and a factory function to create the instance. The factory function receives a Resolver to resolve any dependencies needed to create the instance.","url":"././~/Provider.html","deprecated":false},{"id":"namespace_Provider","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"Provider.provide","file":".","doc":"","url":"././~/Provider.provide.html","deprecated":false},{"id":"namespace_Provider","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"Provider.factory","file":".","doc":"","url":"././~/Provider.factory.html","deprecated":false},{"id":"namespace_Resolved","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"Resolved","file":".","doc":"Cached resolved value with reference count. This is used internally by the Injector to manage instances and their lifetimes.","url":"././~/Resolved.html","deprecated":false},{"id":"namespace_Resolved","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"Resolved.value","file":".","doc":"","url":"././~/Resolved.value.html","deprecated":false},{"id":"namespace_Resolved","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"Resolved.refCount","file":".","doc":"","url":"././~/Resolved.refCount.html","deprecated":false},{"id":"namespace_Resolver","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"Resolver","file":".","doc":"Resolver interface for resolving dependencies. It defines a method to resolve a token to its value. Implemented by the Injector class.","url":"././~/Resolver.html","deprecated":false},{"id":"namespace_Resolver","kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"Resolver.resolve","file":".","doc":"","url":"././~/Resolver.resolve.html","deprecated":false},{"id":"namespace_Target","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"Target","file":".","doc":"Real Function type.","url":"././~/Target.html","deprecated":false},{"id":"namespace_Token","kind":[{"char":"T","kind":"TypeAlias","title":"Type Alias"}],"name":"Token","file":".","doc":"Token type for dependency injection. It can be a string, symbol, or a class constructor.","url":"././~/Token.html","deprecated":false},{"id":"namespace_collect","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"collect","file":".","doc":"Collect and merge multiple descriptor functions into a single descriptor object. Each function is applied in sequence, allowing for modular and reusable descriptor definitions.","url":"././~/collect.html","deprecated":false},{"id":"namespace_getInjectable","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"getInjectable","file":".","doc":"Read injectable metadata from a target if present.","url":"././~/getInjectable.html","deprecated":false},{"id":"namespace_getInjector","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"getInjector","file":".","doc":"Read the injector instance associated with a target if present.","url":"././~/getInjector.html","deprecated":false},{"id":"namespace_getModule","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"getModule","file":".","doc":"Read module metadata from a target if present.","url":"././~/getModule.html","deprecated":false},{"id":"namespace_read","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"read","file":".","doc":"Safely read a property from a target using a symbol key. Returns undefined if the property does not exist.","url":"././~/read.html","deprecated":false},{"id":"namespace_setInjectable","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"setInjectable","file":".","doc":"Define injectable metadata on a target using a symbol-keyed property. Defaults to an empty dependency list when not provided.","url":"././~/setInjectable.html","deprecated":false},{"id":"namespace_setInjector","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"setInjector","file":".","doc":"Attach an Injector instance to a target (class/function/object) using a symbol-keyed property.","url":"././~/setInjector.html","deprecated":false},{"id":"namespace_setModule","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"setModule","file":".","doc":"Define module metadata on a target using a symbol-keyed property. Empty arrays are applied by default for imports and providers when omitted.","url":"././~/setModule.html","deprecated":false},{"id":"namespace_write","kind":[{"char":"f","kind":"Function","title":"Function"}],"name":"write","file":".","doc":"Safely write a property to a target using a symbol key. Throws an error if the property already exists to prevent accidental overwrites.","url":"././~/write.html","deprecated":false}]};
})()