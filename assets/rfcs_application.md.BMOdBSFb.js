import{_ as a,c as t,o,ae as i}from"./chunks/framework.C3g5OKNe.js";const u=JSON.parse('{"title":"Specifications: Decorator-based Dependency Injection","description":"","frontmatter":{"outline":[2,4]},"headers":[],"relativePath":"rfcs/application.md","filePath":"rfcs/application.md"}'),n={name:"rfcs/application.md"};function r(l,e,s,d,c,h){return o(),t("div",null,[...e[0]||(e[0]=[i('<h1 id="specifications-decorator-based-dependency-injection" tabindex="-1">Specifications: Decorator-based Dependency Injection <a class="header-anchor" href="#specifications-decorator-based-dependency-injection" aria-label="Permalink to &quot;Specifications: Decorator-based Dependency Injection&quot;">​</a></h1><table class="properties"><tbody><tr><th>Status</th><td>testing</td></tr><tr><th>Created</th><td>2025-08-10</td></tr><tr><th>Target</th><td>TypeScript (ECMAScript decorators)</td></tr></tbody></table><nav class="table-of-contents"><ul><li><a href="#problem-statement">Problem Statement</a></li><li><a href="#summary">Summary</a></li><li><a href="#terminology">Terminology</a></li><li><a href="#stages">Stages</a></li><li><a href="#implementation-details">Implementation Details</a><ul><li><a href="#the-module-decorator">The @Module Decorator</a></li><li><a href="#the-controller-decorator">The @Controller Decorator</a></li><li><a href="#the-methods-decorators">The Methods Decorators</a></li></ul></li></ul></nav><h2 id="problem-statement" tabindex="-1">Problem Statement <a class="header-anchor" href="#problem-statement" aria-label="Permalink to &quot;Problem Statement&quot;">​</a></h2><p>While DI provides the mechanism to wire up dependencies, we still need a way create entire object graphs and execute the application.</p><p>This RFC proposes the application lifecycle and composition model for building applications with CHO.</p><h2 id="summary" tabindex="-1">Summary <a class="header-anchor" href="#summary" aria-label="Permalink to &quot;Summary&quot;">​</a></h2><ul><li>Introduce an application lifecycle with bootstrap and shutdown phases.</li><li>Define an application root module as the entry point for configuring the DI context.</li><li>Support module imports to compose larger applications from smaller modules.</li><li>Provide lifecycle hooks for initialization and cleanup.</li><li>Enable configuration and environment-specific overrides via modules.</li><li>Ensure cross-runtime compatibility by avoiding runtime-specific features.</li></ul><h2 id="terminology" tabindex="-1">Terminology <a class="header-anchor" href="#terminology" aria-label="Permalink to &quot;Terminology&quot;">​</a></h2><ul><li><strong>Endpoint</strong> : The entry point of the application, e.g., an HTTP server, a CLI command, etc.</li><li><strong>Controller</strong> : A class that handles incoming requests or commands. A container for endpoints.</li><li><strong>Module</strong>: A class that provide a DI context. A container for providers and controllers (feature).</li><li><strong>Middleware</strong>: A function that intercepts process before reaching the endpoint handler.</li><li><strong>Error Handler</strong>: A function that handles errors thrown during endpoint processing.</li></ul><h2 id="stages" tabindex="-1">Stages <a class="header-anchor" href="#stages" aria-label="Permalink to &quot;Stages&quot;">​</a></h2><h4 id="build-module-graph" tabindex="-1">Build Module Graph <a class="header-anchor" href="#build-module-graph" aria-label="Permalink to &quot;Build Module Graph&quot;">​</a></h4><p>The first stage of the application lifecycle is to build an abstract graph of modules and their dependencies by reading the metadata set by the decorators.</p><h4 id="compilation" tabindex="-1">Compilation <a class="header-anchor" href="#compilation" aria-label="Permalink to &quot;Compilation&quot;">​</a></h4><p>The next stage starts by bootstrapping a root module, which is an injectable class annotated with the <code>@Module</code> decorator. The compiler search for controllers and endpoints recursively in the module imports, resolving and instantiating all dependencies. The result is a tree of resolved modules with their providers, dependencies, controllers, and their endpoints bound and ready to be invoked.</p><p>The compilation stage is the first <strong>initialization</strong> phase of the application lifecycle. It is an async process and ends when all dependencies are resolved and instantiated. Any setup task should be done in this phase.</p><h4 id="initialization" tabindex="-1">Initialization <a class="header-anchor" href="#initialization" aria-label="Permalink to &quot;Initialization&quot;">​</a></h4><p>For more complex initialization tasks, the framework provide a lifecycle hook <code>onModuleInit</code> that can be implemented by module classes. The method is called once all dependencies are resolved and instantiated, but before any endpoint is invoked.</p><h4 id="linking" tabindex="-1">Linking <a class="header-anchor" href="#linking" aria-label="Permalink to &quot;Linking&quot;">​</a></h4><p>The linking stage is the process of binding the endpoints to their respective handlers, setting up middleware and error handlers. This stage is specific to the type of application being built (e.g., web server, CLI app, etc.) and is responsible for preparing the application to handle incoming requests or commands.</p><h4 id="activation" tabindex="-1">Activation <a class="header-anchor" href="#activation" aria-label="Permalink to &quot;Activation&quot;">​</a></h4><p>Another lifecycle hook <code>onModuleActivate</code> is provided for modules to activate any runtime-specific features, such as starting a server, listening to events, etc. The method is called once the application is fully linked and ready to handle requests or commands.</p><h4 id="running" tabindex="-1">Running <a class="header-anchor" href="#running" aria-label="Permalink to &quot;Running&quot;">​</a></h4><p>Once the application is fully initialized and activated, it enters the running phase. In this phase, the application handles incoming requests or commands, invoking the appropriate controllers and endpoints.</p><h4 id="shutdown" tabindex="-1">Shutdown <a class="header-anchor" href="#shutdown" aria-label="Permalink to &quot;Shutdown&quot;">​</a></h4><p>When the application is signaled to shut down (e.g., via a termination signal), it enters the shutdown phase. During this phase, the application should clean up resources, close connections, and perform any necessary teardown tasks.</p><h2 id="implementation-details" tabindex="-1">Implementation Details <a class="header-anchor" href="#implementation-details" aria-label="Permalink to &quot;Implementation Details&quot;">​</a></h2><h3 id="the-module-decorator" tabindex="-1">The <code>@Module</code> Decorator <a class="header-anchor" href="#the-module-decorator" aria-label="Permalink to &quot;The `@Module` Decorator&quot;">​</a></h3><h3 id="the-controller-decorator" tabindex="-1">The <code>@Controller</code> Decorator <a class="header-anchor" href="#the-controller-decorator" aria-label="Permalink to &quot;The `@Controller` Decorator&quot;">​</a></h3><h3 id="the-methods-decorators" tabindex="-1">The Methods Decorators <a class="header-anchor" href="#the-methods-decorators" aria-label="Permalink to &quot;The Methods Decorators&quot;">​</a></h3>',30)])])}const m=a(n,[["render",r]]);export{u as __pageData,m as default};
