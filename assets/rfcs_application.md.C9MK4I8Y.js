import{_ as t,c as a,o as i,ae as o}from"./chunks/framework.C3g5OKNe.js";const m=JSON.parse('{"title":"Specifications: Decorator-based Dependency Injection","description":"","frontmatter":{"outline":[2,4]},"headers":[],"relativePath":"rfcs/application.md","filePath":"rfcs/application.md"}'),n={name:"rfcs/application.md"};function r(l,e,s,c,d,p){return i(),a("div",null,[...e[0]||(e[0]=[o('<h1 id="specifications-decorator-based-dependency-injection" tabindex="-1">Specifications: Decorator-based Dependency Injection <a class="header-anchor" href="#specifications-decorator-based-dependency-injection" aria-label="Permalink to &quot;Specifications: Decorator-based Dependency Injection&quot;">​</a></h1><table class="properties"><tbody><tr><th>Status</th><td>testing</td></tr><tr><th>Created</th><td>2025-08-10</td></tr><tr><th>Target</th><td>TypeScript (ECMAScript decorators)</td></tr></tbody></table><nav class="table-of-contents"><ul><li><a href="#problem-statement">Problem Statement</a></li><li><a href="#summary">Summary</a></li><li><a href="#terminology">Terminology</a></li><li><a href="#stages">Stages</a><ul><li><a href="#compilation">Compilation</a></li></ul></li></ul></nav><h2 id="problem-statement" tabindex="-1">Problem Statement <a class="header-anchor" href="#problem-statement" aria-label="Permalink to &quot;Problem Statement&quot;">​</a></h2><p>While DI provides the mechanism to wire up dependencies, we still need a way create entire object graphs and execute the application.</p><p>This RFC proposes the application lifecycle and composition model for building applications with CHO.</p><h2 id="summary" tabindex="-1">Summary <a class="header-anchor" href="#summary" aria-label="Permalink to &quot;Summary&quot;">​</a></h2><ul><li>Introduce an application lifecycle with bootstrap and shutdown phases.</li><li>Define an application root module as the entry point for configuring the DI context.</li><li>Support module imports to compose larger applications from smaller modules.</li><li>Provide lifecycle hooks for initialization and cleanup.</li><li>Enable configuration and environment-specific overrides via modules.</li><li>Ensure cross-runtime compatibility by avoiding runtime-specific features.</li></ul><h2 id="terminology" tabindex="-1">Terminology <a class="header-anchor" href="#terminology" aria-label="Permalink to &quot;Terminology&quot;">​</a></h2><ul><li><strong>Endpoint</strong> : The entry point of the application, e.g., an HTTP server, a CLI command, etc.</li><li><strong>Controller</strong> : A class that handles incoming requests or commands. A container for endpoints.</li><li><strong>Module</strong>: A class that provide a DI context. A container for providers and controllers (feature).</li><li><strong>Middleware</strong>: A function that intercepts process before reaching the endpoint handler.</li><li><strong>Error Handler</strong>: A function that handles errors thrown during endpoint processing.</li></ul><h2 id="stages" tabindex="-1">Stages <a class="header-anchor" href="#stages" aria-label="Permalink to &quot;Stages&quot;">​</a></h2><h3 id="compilation" tabindex="-1">Compilation <a class="header-anchor" href="#compilation" aria-label="Permalink to &quot;Compilation&quot;">​</a></h3><p>The first stage takes the root module and build the module graph, resolving all dependencies. Instantiating all controllers and create unique handlers for each endpoint.</p><p>Using the metadata emitted by the decorators, a compile step generates a tree of resolved modules with their providers and dependencies.</p>',14)])])}const u=t(n,[["render",r]]);export{m as __pageData,u as default};
