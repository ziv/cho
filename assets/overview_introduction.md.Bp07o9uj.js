import{_ as t,c as a,o,ae as i}from"./chunks/framework.C3g5OKNe.js";const u=JSON.parse('{"title":"Introduction","description":"","frontmatter":{"outline":1},"headers":[],"relativePath":"overview/introduction.md","filePath":"overview/introduction.md"}'),r={name:"overview/introduction.md"};function n(s,e,l,d,c,h){return o(),a("div",null,[...e[0]||(e[0]=[i('<h1 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-label="Permalink to &quot;Introduction&quot;">​</a></h1><p>Or...<strong><em>Why This Project Exists</em></strong></p><h3 id="portability" tabindex="-1">Portability <a class="header-anchor" href="#portability" aria-label="Permalink to &quot;Portability&quot;">​</a></h3><p>In the modern software development landscape, the ability to deploy applications across various environments and platforms is crucial. Developers often face challenges when trying to ensure that their applications run seamlessly on different runtimes such as <strong>Node.js</strong>, <strong>Deno</strong>, <strong>Bun</strong>, <strong>Cloudflare Workers</strong>, <strong>AWS Lambda</strong> and more. Each of these runtimes has its own set of features, performance characteristics, and limitations, making it difficult to write code that is truly portable.</p><h3 id="standardization" tabindex="-1">Standardization <a class="header-anchor" href="#standardization" aria-label="Permalink to &quot;Standardization&quot;">​</a></h3><p>Decorators and reflect metadata are not yet part of the official ECMAScript standard, leading to inconsistencies in their implementation across different runtimes. This lack of standardization can result in compatibility issues and hinder the adoption of these features in production environments. This project aims to provide a consistent and reliable way to use decorators across multiple JavaScript runtimes, ensuring that developers can leverage these powerful features without worrying about compatibility issues.</p><p>We embraced the <a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="noreferrer">latest (stage 3) TC39 proposals for decorators</a>, following <a href="https://decorators.deno.dev/" target="_blank" rel="noreferrer">Deno&#39;s lead</a> in adopting these features.</p><h3 id="field-experience" tabindex="-1">Field Experience <a class="header-anchor" href="#field-experience" aria-label="Permalink to &quot;Field Experience&quot;">​</a></h3><p>Working alongside engineers using Angular and NestJS frameworks, we observed a common desire for a more streamlined and efficient way to build server-side applications. Teams love the class based API approach and the decorator syntax, but often find themselves constrained by the limitations of their chosen runtime or framework.</p><p>The expansion of serverless computing and the rise of edge computing have further highlighted the need for a unified approach</p><h2 id="philosophy" tabindex="-1">Philosophy <a class="header-anchor" href="#philosophy" aria-label="Permalink to &quot;Philosophy&quot;">​</a></h2><p>It can be simpler. It can be better. Why not?</p><h2 id="what-can-you-do-with-it" tabindex="-1">What Can You Do With It? <a class="header-anchor" href="#what-can-you-do-with-it" aria-label="Permalink to &quot;What Can You Do With It?&quot;">​</a></h2><p>Any Node.js application can be deployed using this project. Here are some examples:</p><ul><li>HTTP Server</li><li>CLI Applications</li><li>REST API</li><li>Any TCP Server</li><li>Cloud Functions</li><li>WebSocket Server</li><li>Cron Jobs</li><li>And More...</li></ul>',15)])])}const f=t(r,[["render",n]]);export{u as __pageData,f as default};
