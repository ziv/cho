import{_ as a,c as t,o,ae as i}from"./chunks/framework.C3g5OKNe.js";const u=JSON.parse('{"title":"Specifications: Decorator-based Dependency Injection","description":"","frontmatter":{"outline":[2,4]},"headers":[],"relativePath":"rfcs/application.md","filePath":"rfcs/application.md"}'),n={name:"rfcs/application.md"};function r(l,e,d,s,c,h){return o(),t("div",null,[...e[0]||(e[0]=[i('<h1 id="specifications-decorator-based-dependency-injection" tabindex="-1">Specifications: Decorator-based Dependency Injection <a class="header-anchor" href="#specifications-decorator-based-dependency-injection" aria-label="Permalink to &quot;Specifications: Decorator-based Dependency Injection&quot;">​</a></h1><table class="properties"><tbody><tr><th>Status</th><td>testing</td></tr><tr><th>Created</th><td>2025-08-10</td></tr><tr><th>Target</th><td>TypeScript (ECMAScript decorators)</td></tr></tbody></table><nav class="table-of-contents"><ul><li><a href="#problem-statement">Problem Statement</a></li><li><a href="#summary">Summary</a></li><li><a href="#terminology">Terminology</a></li><li><a href="#building-blocks">Building Blocks</a><ul><li><a href="#error-handling">Error Handling</a></li><li><a href="#middleware">Middleware</a></li><li><a href="#module">Module</a></li><li><a href="#controller">Controller</a></li><li><a href="#endpoint">Endpoint</a></li></ul></li><li><a href="#stages">Stages</a></li><li><a href="#implementation-details">Implementation Details</a><ul><li><a href="#the-module-decorator">The @Module Decorator</a></li><li><a href="#the-controller-decorator">The @Controller Decorator</a></li><li><a href="#the-methods-decorators">The Methods Decorators</a></li><li><a href="#middlewares">Middlewares</a></li><li><a href="#error-handling-1">Error Handling</a></li></ul></li></ul></nav><h2 id="problem-statement" tabindex="-1">Problem Statement <a class="header-anchor" href="#problem-statement" aria-label="Permalink to &quot;Problem Statement&quot;">​</a></h2><p>While DI provides the mechanism to wire up dependencies, we still need a way create entire object graphs and execute the application.</p><p>This RFC proposes the application lifecycle and composition model for building applications with CHO.</p><h2 id="summary" tabindex="-1">Summary <a class="header-anchor" href="#summary" aria-label="Permalink to &quot;Summary&quot;">​</a></h2><ul><li>Introduce an application lifecycle with bootstrap and shutdown phases.</li><li>Define an application root module as the entry point for configuring the DI context.</li><li>Support module imports to compose larger applications from smaller modules.</li><li>Provide lifecycle hooks for initialization and cleanup.</li><li>Enable configuration and environment-specific overrides via modules.</li><li>Ensure cross-runtime compatibility by avoiding runtime-specific features.</li></ul><h2 id="terminology" tabindex="-1">Terminology <a class="header-anchor" href="#terminology" aria-label="Permalink to &quot;Terminology&quot;">​</a></h2><ul><li><strong>Endpoint</strong> : The entry point of the application, e.g., an HTTP server, a CLI command, etc.</li><li><strong>Controller</strong> : A class that handles incoming requests or commands. A container for endpoints.</li><li><strong>Module</strong>: A class that provide a DI context. A container for providers and controllers (feature).</li><li><strong>Middleware</strong>: A function that intercepts process before reaching the endpoint handler.</li><li><strong>Error Handler</strong>: A function that handles errors thrown during endpoint processing.</li></ul><h2 id="building-blocks" tabindex="-1">Building Blocks <a class="header-anchor" href="#building-blocks" aria-label="Permalink to &quot;Building Blocks&quot;">​</a></h2><p>This chapter is relying on concepts defined in the <a href="./di.html">Dependency Injection RFC</a>.</p><h3 id="error-handling" tabindex="-1">Error Handling <a class="header-anchor" href="#error-handling" aria-label="Permalink to &quot;Error Handling&quot;">​</a></h3><p>Error handling is done via error handlers that can be registered at any level (module, controller, endpoint). Error handlers are functions that take an error and the request context as arguments.</p><p>For an error handler require dependencies, it can be defined as an injectable class with a <code>catch</code> method, implementing <code>ChoErrorHandler</code> interface.</p><h3 id="middleware" tabindex="-1">Middleware <a class="header-anchor" href="#middleware" aria-label="Permalink to &quot;Middleware&quot;">​</a></h3><p>Middleware used to intercept the request processing pipeline. Middleware can be registered at any level (module, controller, endpoint). Middleware are functions that take the request context and a <code>next</code> function as arguments.</p><p>For a middleware require dependencies, it can be defined as an injectable class with a <code>handle</code> method, implementing <code>ChoMiddleware</code> interface.</p><h3 id="module" tabindex="-1">Module <a class="header-anchor" href="#module" aria-label="Permalink to &quot;Module&quot;">​</a></h3><p>The application specifications extends the use of modules as defined in the <a href="./di.html">Dependency Injection RFC</a> to contain controllers, error handlers, and middleware.</p><p>A module is required to bootstrap the application. The root module is passed to the application bootstrap function.</p><h3 id="controller" tabindex="-1">Controller <a class="header-anchor" href="#controller" aria-label="Permalink to &quot;Controller&quot;">​</a></h3><p>A controller is an injectable class annotated with the <code>@Controller</code> decorator. A controller can contain multiple endpoints, error handlers, and middleware.</p><h3 id="endpoint" tabindex="-1">Endpoint <a class="header-anchor" href="#endpoint" aria-label="Permalink to &quot;Endpoint&quot;">​</a></h3><p>An endpoint is an asynchronous method within a controller, annotated with decorators depending on the type of application being built (e.g., <code>@Get</code>, <code>@Post</code> for web applications).</p><hr><h2 id="stages" tabindex="-1">Stages <a class="header-anchor" href="#stages" aria-label="Permalink to &quot;Stages&quot;">​</a></h2><p>The application lifecycle consists of the following stages:</p><h4 id="build-module-graph" tabindex="-1">Build Module Graph <a class="header-anchor" href="#build-module-graph" aria-label="Permalink to &quot;Build Module Graph&quot;">​</a></h4><p>The first stage of the application lifecycle is to build an abstract graph of modules and their dependencies by reading the metadata set by the decorators.</p><h4 id="compilation" tabindex="-1">Compilation <a class="header-anchor" href="#compilation" aria-label="Permalink to &quot;Compilation&quot;">​</a></h4><p>The next stage starts by bootstrapping a root module, which is an injectable class annotated with the <code>@Module</code> decorator. The compiler search for controllers and endpoints recursively in the module imports, resolving and instantiating all dependencies. The result is a tree of resolved modules with their providers, dependencies, controllers, and their endpoints bound and ready to be invoked.</p><p>The compilation stage is the first <strong>initialization</strong> phase of the application lifecycle. It is an async process and ends when all dependencies are resolved and instantiated. Any setup task should be done in this phase.</p><p>The compilation stage is an asynchronous process.</p><h4 id="initialization" tabindex="-1">Initialization <a class="header-anchor" href="#initialization" aria-label="Permalink to &quot;Initialization&quot;">​</a></h4><p>For more complex initialization tasks, the framework provide a lifecycle hook <code>onModuleInit</code> that can be implemented by module classes. The method is called once all dependencies are resolved and instantiated, but before any endpoint is invoked.</p><h4 id="linking" tabindex="-1">Linking <a class="header-anchor" href="#linking" aria-label="Permalink to &quot;Linking&quot;">​</a></h4><p>The linking stage is the process of binding the endpoints to their respective handlers, setting up middleware and error handlers. This stage is specific to the type of application being built (e.g., web server, CLI app, etc.) and is responsible for preparing the application to handle incoming requests or commands.</p><h4 id="activation" tabindex="-1">Activation <a class="header-anchor" href="#activation" aria-label="Permalink to &quot;Activation&quot;">​</a></h4><p>Another lifecycle hook <code>onModuleActivate</code> is provided for modules to activate any runtime-specific features, such as starting a server, listening to events, etc. The method is called once the application is fully linked and ready to handle requests or commands.</p><h4 id="running" tabindex="-1">Running <a class="header-anchor" href="#running" aria-label="Permalink to &quot;Running&quot;">​</a></h4><p>Once the application is fully initialized and activated, it enters the running phase. In this phase, the application handles incoming requests or commands, invoking the appropriate controllers and endpoints.</p><h4 id="shutdown" tabindex="-1">Shutdown <a class="header-anchor" href="#shutdown" aria-label="Permalink to &quot;Shutdown&quot;">​</a></h4><p>When the application is signaled to shut down (e.g., via a termination signal), it enters the shutdown phase. During this phase, the application should clean up resources, close connections, and perform any necessary teardown tasks. The lifecycle hook <code>onModuleShutdown</code> can be implemented by module classes to handle cleanup tasks.</p><h2 id="implementation-details" tabindex="-1">Implementation Details <a class="header-anchor" href="#implementation-details" aria-label="Permalink to &quot;Implementation Details&quot;">​</a></h2><h3 id="the-module-decorator" tabindex="-1">The <code>@Module</code> Decorator <a class="header-anchor" href="#the-module-decorator" aria-label="Permalink to &quot;The `@Module` Decorator&quot;">​</a></h3><h3 id="the-controller-decorator" tabindex="-1">The <code>@Controller</code> Decorator <a class="header-anchor" href="#the-controller-decorator" aria-label="Permalink to &quot;The `@Controller` Decorator&quot;">​</a></h3><h3 id="the-methods-decorators" tabindex="-1">The Methods Decorators <a class="header-anchor" href="#the-methods-decorators" aria-label="Permalink to &quot;The Methods Decorators&quot;">​</a></h3><h3 id="middlewares" tabindex="-1">Middlewares <a class="header-anchor" href="#middlewares" aria-label="Permalink to &quot;Middlewares&quot;">​</a></h3><h3 id="error-handling-1" tabindex="-1">Error Handling <a class="header-anchor" href="#error-handling-1" aria-label="Permalink to &quot;Error Handling&quot;">​</a></h3>',50)])])}const m=a(n,[["render",r]]);export{u as __pageData,m as default};
